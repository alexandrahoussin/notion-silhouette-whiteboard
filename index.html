<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whiteboard Silhouettes</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f9f9f9;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      display: flex;
      justify-content: center;
      gap: 10px;
      background: #fff;
      padding: 10px;
      border-bottom: 1px solid #ddd;
      flex-wrap: wrap;
      width: 100%;
    }

    .dropdown {
      position: relative;
      display: inline-block;
    }

    .dropbtn {
      background-color: #4CAF50;
      color: white;
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      cursor: pointer;
      border-radius: 6px;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      background-color: white;
      min-width: 180px;
      box-shadow: 0px 4px 6px rgba(0,0,0,0.15);
      z-index: 1;
      border-radius: 6px;
      padding: 8px;
    }

    .dropdown-content label,
    .dropdown-content button {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      padding: 6px;
      margin: 4px 0;
      text-align: left;
      font-size: 14px;
      background: none;
      border: none;
      cursor: pointer;
      width: 100%;
    }

    .dropdown-content input[type="file"] {
      width: 100%;
    }

    .dropdown:hover .dropdown-content {
      display: block;
    }

    .color-box, .pattern-box {
      width: 24px;
      height: 24px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-left: 10px;
      cursor: pointer;
    }

    .selected {
      outline: 2px solid deeppink;
    }

    #toolbar {
      margin: 10px 0;
      display: flex;
      gap: 10px;
    }

    canvas {
      border: 1px solid #ccc;
      margin: 20px auto;
      display: block;
      background: white;
      max-width: 95vw;
      max-height: 70vh;
      cursor: crosshair;
    }

    #placeholder {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      color: #aaa;
      font-size: 18px;
      pointer-events: none;
    }

    footer {
      margin: 10px 0;
      display: flex;
      gap: 10px;
    }
  </style>
</head>
<body>
  <header>
    <!-- Menu Silhouette -->
    <div class="dropdown">
      <button class="dropbtn">Silhouette</button>
      <div class="dropdown-content">
        <button onclick="addSilhouette('femme.png')">Femme</button>
        <button onclick="addSilhouette('homme.png')">Homme</button>
        <button onclick="addSilhouette('enfant.png')">Enfant</button>
        <button onclick="addSilhouette('bebe.png')">B√©b√©</button>
        <label>
          Ajouter une image
          <input type="file" accept="image/*" onchange="uploadSilhouette(event)">
        </label>
        <button onclick="removeSilhouette()">Supprimer silhouette</button>
      </div>
    </div>

    <!-- Menu Dessin -->
    <div class="dropdown">
      <button class="dropbtn">Dessin</button>
      <div class="dropdown-content">
        <label>
          Couleur
          <input type="color" id="drawColor" onchange="setDrawColor(this.value)">
        </label>
        <label>
          Largeur
          <input type="range" id="lineWidth" min="1" max="20" value="2" onchange="setLineWidth(this.value)">
        </label>
      </div>
    </div>

    <!-- Menu Remplissage -->
    <div class="dropdown">
      <button class="dropbtn">Remplissage</button>
      <div class="dropdown-content">
        <label>
          Couleur
          <div id="fillColorBox" class="color-box selected" style="background: red;" onclick="setFillMode('color')"></div>
          <input type="color" id="fillColor" onchange="setFillColor(this.value)" style="display:none;">
        </label>
        <label>
          Motif
          <div id="patternBox" class="pattern-box" onclick="setFillMode('pattern')"></div>
          <input type="file" id="patternUpload" accept="image/*" onchange="setPattern(event)" style="display:none;">
        </label>
      </div>
    </div>

    <!-- Modes -->
    <button id="drawModeBtn" onclick="setMode('draw')">‚úèÔ∏è Mode dessin</button>
    <button id="fillModeBtn" onclick="setMode('fill')">ü™£ Mode remplissage</button>
    <button id="moveModeBtn" onclick="setMode('move')">‚úã D√©placer</button>
  </header>

  <div id="toolbar">
    <button onclick="undo()">‚Ü©Ô∏è Annuler</button>
    <button onclick="redo()">‚Ü™Ô∏è R√©tablir</button>
    <button onclick="clearCanvas()">üóëÔ∏è Effacer</button>
    <button onclick="zoomIn()">‚ûï Zoom</button>
    <button onclick="zoomOut()">‚ûñ D√©zoom</button>
  </div>

  <div id="placeholder">Ici je laisse place √† mon imagination, je peux √©galement choisir une silhouette..</div>
  <canvas id="canvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const placeholder = document.getElementById('placeholder');

    let drawing = false;
    let mode = 'draw';
    let drawColor = '#000';
    let fillColor = '#f00';
    let lineWidth = 2;
    let fillMode = 'color';
    let fillPattern = null;
    let silhouetteImg = null;

    let scale = 1;
    let offsetX = 0, offsetY = 0;

    let history = [];
    let historyStep = -1;

    function saveState() {
      history = history.slice(0, historyStep + 1);
      history.push(canvas.toDataURL());
      historyStep++;
    }

    function restoreState(step) {
      const img = new Image();
      img.src = history[step];
      img.onload = () => {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0);
        ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
      };
    }

    function undo() { if (historyStep > 0) restoreState(--historyStep); }
    function redo() { if (historyStep < history.length-1) restoreState(++historyStep); }

    function setMode(m) {
      mode = m;
      canvas.style.cursor = m === 'move' ? 'grab' : (m === 'fill' ? 'url("bucket.svg"), auto' : 'crosshair');
    }

    function setDrawColor(color) { drawColor = color; }
    function setFillColor(color) { fillColor = color; document.getElementById('fillColorBox').style.background = color; }
    function setLineWidth(width) { lineWidth = width; }

    function setFillMode(mode) {
      fillMode = mode;
      document.getElementById('fillColorBox').classList.toggle('selected', mode==='color');
      document.getElementById('patternBox').classList.toggle('selected', mode==='pattern');
    }

    function setPattern(event) {
      const file = event.target.files[0];
      if (!file) return;
      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        fillPattern = ctx.createPattern(img, 'repeat');
        document.getElementById('patternBox').style.backgroundImage = `url(${img.src})`;
        document.getElementById('patternBox').style.backgroundSize = 'cover';
      };
    }

    function addSilhouette(src) {
      const img = new Image();
      img.src = src;
      img.onload = () => { silhouetteImg = img; redraw(); };
    }

    function uploadSilhouette(event) {
      const file = event.target.files[0];
      if (!file) return;
      const img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = () => { silhouetteImg = img; redraw(); };
    }

    function removeSilhouette() { silhouetteImg = null; redraw(); }

    function clearCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (silhouetteImg) ctx.drawImage(silhouetteImg, canvas.width/4, canvas.height/4, canvas.width/2, canvas.height/2);
      saveState();
    }

    function zoomIn() { scale *= 1.2; redraw(); }
    function zoomOut() { scale /= 1.2; redraw(); }

    function redraw() {
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
      if (historyStep >= 0) {
        const img = new Image();
        img.src = history[historyStep];
        img.onload = () => {
          ctx.drawImage(img,0,0);
          if (silhouetteImg) ctx.drawImage(silhouetteImg, canvas.width/4, canvas.height/4, canvas.width/2, canvas.height/2);
        };
      } else if (silhouetteImg) {
        ctx.drawImage(silhouetteImg, canvas.width/4, canvas.height/4, canvas.width/2, canvas.height/2);
      }
    }

    function getCanvasPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: (clientX - rect.left - offsetX) / scale,
        y: (clientY - rect.top - offsetY) / scale
      };
    }

    function startDraw(e) {
      if (mode === 'draw') {
        drawing = true;
        const pos = getCanvasPos(e);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        placeholder.style.display = 'none';
      } else if (mode === 'fill') {
        const pos = getCanvasPos(e);
        ctx.fillStyle = (fillMode === 'color') ? fillColor : fillPattern;
        ctx.fillRect(pos.x-1, pos.y-1, 3, 3); // basic fill placeholder
        saveState();
      } else if (mode === 'move') {
        drawing = true;
        canvas.style.cursor = 'grabbing';
        lastX = e.clientX || e.touches[0].clientX;
        lastY = e.clientY || e.touches[0].clientY;
      }
    }

    function draw(e) {
      if (!drawing) return;
      if (mode === 'draw') {
        const pos = getCanvasPos(e);
        ctx.lineTo(pos.x, pos.y);
        ctx.strokeStyle = drawColor;
        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'round';
        ctx.stroke();
      } else if (mode === 'move') {
        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;
        offsetX += (clientX - lastX);
        offsetY += (clientY - lastY);
        lastX = clientX;
        lastY = clientY;
        redraw();
      }
    }

    function endDraw() {
      if (drawing && mode === 'draw') {
        ctx.closePath();
        saveState();
      }
      drawing = false;
      if (mode === 'move') canvas.style.cursor = 'grab';
    }

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('mouseleave', endDraw);
    canvas.addEventListener('touchstart', startDraw);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', endDraw);

    saveState();
  </script>
</body>
</html>
